// Synth.h

#ifndef SYNTH_H_INCLUDED
#define SYNTH_H_INCLUDED

#include "../JuceLibraryCode/JuceHeader.h"

const int MAX_POLYPHONY = 32;

#include "Filters.h"

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

struct JOSSound : public SynthesiserSound
{
	JOSSound() {}

	bool appliesToNote(int /*midiNoteNumber*/) override { return true; }
	bool appliesToChannel(int /*midiChannel*/) override { return true; }
};

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

class JOSVoice : public SynthesiserVoice
{
private:
	ScopedPointer<JOS> note;

public:
	JOSVoice()
	{ }

	bool canPlaySound(SynthesiserSound* sound) override {
		return sound != nullptr;
	}

	void startNote(int midiNoteNumber, float velocity,
		SynthesiserSound*, int /*currentPitchWheelPosition*/) override {
		note = new JOS(midiNoteNumber, velocity, (float)getSampleRate());
	}

	void stopNote(float /*velocity*/, bool /*allowTailOff*/) override 
	{ }

	void pitchWheelMoved(int /*newValue*/) override
	{ }

	void controllerMoved(int /*controllerNumber*/, int /*newValue*/) override
	{ }

	void renderNextBlock(AudioSampleBuffer& outputBuffer, int startSample, int numSamples) override {
		float* buf = (float *)outputBuffer.getWritePointer(0);
		
		if (note != nullptr) {
			note->renderToBuffer(&buf[startSample], numSamples, isKeyDown() /*|| isSustainPedalDown()*/);
			if (!note->is_alive()) {
				clearCurrentNote();
				note = nullptr;
			}
		}
	}
};

// = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = 

class PiSynthPlayer : public AudioSource
{
private:
	AudioDeviceManager& inputDeviceManager;
	AudioDeviceManager& outputDeviceManager;
	MidiKeyboardState& keyboardState;

	Synthesiser synth;
	MidiMessageCollector midiCollector;

	AudioSourcePlayer audioSourcePlayer;

public:
	PiSynthPlayer(MidiKeyboardState& _state, AudioDeviceManager& _in, AudioDeviceManager& _out)
		: keyboardState(_state), inputDeviceManager(_in), outputDeviceManager(_out)
	{
		inputDeviceManager.addMidiInputCallback(String::empty, &midiCollector);
		inputDeviceManager.setMidiInputEnabled(MidiInput::getDevices()[0], true);

		// AudioDeviceManager& outputDeviceManager 
		//   -> SynthPlayer(:AudioIODeviceCallback) audioSourcePlayer
		outputDeviceManager.addAudioCallback(&audioSourcePlayer);

		// ... -> PiSynthPlayer(:AudioSource)
		audioSourcePlayer.setSource(this);

		for (int i = 0; i < MAX_POLYPHONY; ++i)
			synth.addVoice(new JOSVoice());

		synth.clearSounds();
		synth.addSound(new JOSSound());
	}

	~PiSynthPlayer() {
		audioSourcePlayer.setSource(nullptr);
		inputDeviceManager.removeMidiInputCallback(String::empty, &midiCollector);
		
		outputDeviceManager.removeAudioCallback(&audioSourcePlayer);
		outputDeviceManager.closeAudioDevice();
	}

	void prepareToPlay(int /*samplesPerBlockExpected*/, double sampleRate) override {
		midiCollector.reset(sampleRate);
		synth.setCurrentPlaybackSampleRate(sampleRate);
	}

	void releaseResources() override
	{ }

	void getNextAudioBlock(const AudioSourceChannelInfo& bufferToFill) override {
		bufferToFill.clearActiveBufferRegion();

		MidiBuffer incomingMidi;
		midiCollector.removeNextBlockOfMessages(incomingMidi, bufferToFill.numSamples);

		// pass these messages to the keyboard state so that it can update the component
		// to show on-screen which keys are being pressed on the physical midi keyboard.	
		const int startSample = 0;
		const bool injectIndirectEvents = true;  // add midi messages generated by clicking on the on-screen keyboard.
		keyboardState.processNextMidiBuffer(incomingMidi, startSample, bufferToFill.numSamples, injectIndirectEvents);

		synth.renderNextBlock(*bufferToFill.buffer, incomingMidi, startSample, bufferToFill.numSamples);
	}
};


#endif  // SYNTH_H_INCLUDED
